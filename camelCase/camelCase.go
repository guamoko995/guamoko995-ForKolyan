// camelCase реализована функция преведения потока (в канале)
// рун кода go в snake_case к коду go в camelCase.
package camelCase

type camelCase struct{}

// Набор возможных состояний редактора кода
const (
	DEF  = 0 // обработка блока кода
	BC   = 1 // обработка /*блока комментария*/
	SC   = 2 // обработка //строчного комментария
	Q    = 3 // обработка 'текста внутри одинарных кавычек'
	DQ   = 4 // обработка "текста внутри двойных кавычек"
	HQ   = 5 // обработка `текста внутри жестких кавычек`
	EDIT = 6 // состояние перевода символа в верхний регистр
)

func New() camelCase {
	return camelCase{}
}

// Edit получает код из канала input и приводит snake_case к camelCase только внутри
// блоков кода (названия переменных, пакетов, методов и констант). Отедактированный
// код кладет в канал out.
func (camelCase) Edit(input chan rune, output chan rune) {
	state := DEF
	var prev rune
	for c := range input {
		switch state {
		// Поведение редактора в состоянии просмотра блока кода.
		case DEF:
			switch c {
			case '/':
				if prev == '/' {
					state = SC // переход в состояние просмотра //строчного комментария
				}
			case '*':
				if prev == '/' {
					state = BC // переход в состояние просмотра /*блочного комментария*/
				}
			case '\'':
				state = Q // переход в состояние просмотра 'текста в одинарных кавычках'
			case '"':
				state = DQ // переход в состояние просмотра "текста в двойных кавычках"
			case '`':
				state = HQ // переход в состояние просмотра `текста в жестких кавычках`
			case '_':
				if ('a' <= prev && prev <= 'z') || ('A' <= prev && prev <= 'Z') {
					state = EDIT // переход в состояние исправления snake_case на camelCase
					prev = c
					continue // игнорирование подчеркиваний следующих не после буквы
				}
			}
		// Поведение редактора в состоянии исправления snake_case на camelCase
		case EDIT:
			switch {
			case 'a' <= c && c <= 'z':
				c += 'A' - 'a'
			case c == '_':
				continue // игнорирование лишних подряд идущих подчеркиваний ___
			}
			state = DEF
		// Поведение редактора в состоянии просмотра /*блока комментария*/
		case BC:
			switch c {
			case '/':
				if prev == '*' {
					state = DEF
				}
			}

		// Поведение редактора в состоянии просмотра // строки комментария
		case SC:
			if c == '\n' {
				state = DEF // переход в состояние просмотра блока кода
			}
		// Поыедение редактора в состоянии просмотра 'текста в одинарных кавычках'
		case Q:
			if c == '\'' {
				if prev != '\\' { // символ одинарных кавычек не должен быть экранирован
					state = DEF // переход в состояние просмотра кода
				}
			}
		// Поведение редактора в состоянии просмотра "текста в двойных кавычках"
		case DQ:
			if c == '"' {
				if prev != '\\' { // символ двойных кавычек не должен быть экранирован
					state = DEF // переход в состояние просмотра кода
				}
			}
		// Поведение редактора в состоянии просмотра `текста в жестких кавычках`
		case HQ:
			if c == '`' {
				state = DEF // переход в состояние просмотра кода
			}
		}
		prev = c
		output <- c
	}
	close(output)
}
